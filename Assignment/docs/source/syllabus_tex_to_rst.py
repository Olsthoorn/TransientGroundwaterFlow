#! python3
'''Convert sysllabus tx file tot rst file.

Author: T.N.Olsthoorn
May 10-21 May 2022

pandoc is used.

But after the rst file have been generated they need to be filtered, whcih is also done in this file.

Duplicate figure number have to be removeed.
Inline labels have to be converted so that sphincs sees them correctly,
Inline mathlabels have to be taken out and converted to explicit targets for referencing them.
(Thre can only be one label in a multiling math formula blocl.)

# see the how to doc to find out what needs to be done for sphinx to work.

activate sphinx vertial environment first.

conda activate sphinx

Ths virtual evnromment has been stocked by the required packages and the read the docs theme.

The `confy.py` file in the source directory should be adapted.

>>> import sphinx_rtd_theme
>>> 
>>> html_theme = "sphinx_rtd_theme"  # alabaster'
>>> 
>>> extensions += [
>>>     'sphinx_rtd_theme',
>>>     'sphinx.ext.autodoc',
>>>     'sphinxcontrib.bibtex',
>>>     'sphinx.ext.doctest',
>>>     'sphinx.ext.intersphinx',
>>>     'sphinx.ext.todo',
>>>     'sphinx.ext.coverage',
>>>     'sphinx.ext.ifconfig',
>>>     'sphinx.ext.viewcode',
>>>     ]

>>> bibtex_bibfiles = ['/Users/Theo/Jabref/TransientGroundwater.bib']
 
>>> numfig = True
>>> numfig_secnum_depth = 0
>>> math_eqref_format = 'Eq.{number}'
>>> math_numfig = True
>>> latex_engine = 'pdflatex' # default

The final html files are made in the docs/build/html directory after typing

make clean; make html

from the docs directory.
'''

import os
#import sys
import logging
import re
import numpy as np
import queue

from collections import Counter
from turtle import done
    
def get_nextLine(fin, counter):
    """Generator: returns the next line of the infile.
    
    Args:
        fin: file pointer of infile.
        counter: collections.Counter. Counts lines.
    """
    
    while True:
        s = fin.readline()
        if not s:
            print('Done, {} lines read, {} figures found'.
                  format(counter['lines'], counter['figures']))
        yield s
        counter.update(['lines'])
        
                                                 
def avoidDupNames(infile, outfile):
    """Filter out duplicase figure and table names and if found at a range number.
    
    Multiple equivalent labels originate from figure floats with more than one image (.png) in
    them. The resulting rst yields multiple figure with the same label. This is resolved by
    appending and underscore and a follow-up number (2, 3, 4) ect to these labels.
    
    Afterwards, all labels are unique, and sphinx no longer warns.

    Args:
        infile (.rst): the file generated by pandoc from .tex file, project directory
        outfile (.tmp): file generated by this function for further processing in project dirctory

    Raises:
        FileNotFoundError: input files need to exist
        
    @ TO 20220510
    """
    logging.warning("running avoidDupNames")
     
    if not os.path.isfile(infile):
        raise FileNotFoundError("Can't find {}".format(infile))

    with open(infile, 'r') as fp:
        logging.warning('Infile {} opened ...'.format(infile))

        # Count the figure, tables and compare their labels
        counter = Counter()
        
        line = get_nextLine(fp, counter)
        
        with open(outfile, 'w') as fout:
            logging.warning('Outfile {} opened ...'.format(outfile))
            while True:
                s = next(line)
                if not s: # EOF ?
                    break
                
                k = s.find(':name:', 0) # just look for label `:name:`
                if k >= 0: # got one
                    figName = s[k + len(':name:') :].strip()
                    counter.update([figName]) # Count number of times this label occurs
                    if counter[figName] > 1:
                        s = s.rstrip() + '_' + str(counter[figName] - 1) + '\n'
                    fout.write(s) # write altered string
                else:
                    fout.write(s) # write unaltered string
        logging.warning('... Outfile {} closed.'.format(outfile))
    logging.warning('... Infile {} closed.'.format(infile))
    logging.warning('Labels replaced, see {}'.format(outfile))
    return counter # Counted of each label how many times it occurred.

  
def clean_labels_and_references(infile, outfile):
    """Replace labels for figs, tables, eq to make the seen by sphinx.
    
    To make refrences in Sphinx work, we have to convert the ones obtained from
    
    LyX --> Latex --> pandoc --> rst file
    
    There were a lot of problems, see comments in the code below, next to
    some settings in hte conf.py file.
 
    We run through the input rst file line by line unless we encounter a stand-alone multilie .. math:: block.
    In that case we use a list as stack to allow inserting a label line below the block heading,
    which was already processed. It is stored in the stack, which is written out upon ancountering
    the end of the block, while inserting the new label line as second line of the block.
    
    Args:
        infile (.tmp): tempoaray rst file in project directory without duplicated labels (generated by avoidLabels)
        outfile (.rst): name of the output `.rst` file in the source directory projecdir/docs/source

    Raises:
        FileNotFoundError: _description_
        
    @ TO 20220510
    """
    # Regular expressions for the different tasks    
    RE_name_tab = re.compile(r'(\s*):name: tab:(\S+)\n')
    RE_label_in_captions = re.compile(r'^(\s*(:alt:|\s*.. table::)? )\[\S+\](\S+.*\n)')
    RE_label_sec_headings = re.compile(r'^\[(.*:.*)\](.+)$')
    RE_refs_inline = re.compile(r'(([Ff]igure\s+|[Tt]able\s|[Ee]quation\s+|[Ss]ection\s+|[Pp]aragraph\s+)`\S+ <#(fig:|tbl:|eq:|sec:|subsec:|par:)(\S+)>`__)')
    RE_eq_labels = re.compile(r'(\s*)(\.\. math:: .+)\\label\{(.+)\}$')
    RE_embedded_math_labels = re.compile(r'^(\s+)(.*)\\label\{(eq:\S+)\}(\\end\{aligned\}$|\\\\$)')
    RE_math_block = re.compile('.. math::$')

    logging.warning("clean_labels_and_references avoidDupNames")
     
    if not os.path.isfile(infile):
        raise FileNotFoundError("Can't find {}".format(infile))

    with open(infile, 'r') as fp:
        logging.warning('Infile {} opend ...'.format(infile))
        
        line = get_nextLine(fp, counter)
        
        stack     = [] # Used as FIFO queue to store block lines when processing multi-line math blocks
        mathlabel = '' # Are we in a math block signaled by a line .. math:: ??
        s_old     = '' # previousl line to compare with length of section underlining
        
        with open(outfile, 'w') as fout:
            logging.warning('Outile {} opened ...'.format(outfile))
            
            # Turn the document title lines into comments to exclude original title from TOC
            # (this would otherwise prepend part to all section numbers)            
            s = next(line)
            # Is it a title overline?       
            assert np.all([s[0] == c for c in s[1:-1]]),\
                "Top line in {} is {}... not a '===='... as expected for document title.".format(infile, s[:4])
            # Char used in title header overline
            hdr_line_char = s[0]
            # Comment first line
            fout.write('.. ' + s)
            # Comment rest of title block
            while True:
                s = next(line)
                fout.write('   ' + s) # Comment line
                if s.startswith(hdr_line_char * 3): # Signals end of header block
                    break # So we're done
                        
            # Further process input file line by line
            while True: # till EOF
                s = next(line)
                
                # Check for EOF
                if not s:
                    logging.warning('EOF reached for {}'.format(infile))
                    break  # EOF

                # Check for blank line
                if len(s) == 1: # blank line
                    # Only of we're in a math block add to stack and jump out for 
                    # processing next input line.
                    if len(stack) == 1:
                        stack.append(s)
                        continue

                # Check for staft of multiline math block.
                # If so, open the stack (with this line as first line)
                ro = RE_math_block.search(s)
                if ro:
                    if stack:
                        raise ValueError("Stack not empty upon entering new block.")
                    stack.append(s)
                    continue
                
                # Secion headings may start with thei label between brackes like [text]<rest of ext>.
                # Take this [text] part out and make an explicit sphinx target of it a sand-along block
                # above the original section heading.
                ro = RE_label_sec_headings.search(s)
                if ro:
                    s = '.. _' + ro.group(1) + ':\n' +\
                        '\n' +\
                        ro.group(2) + '\n'
                
                # One-line math blocks may contain a label at end of the line like ...\\label{...}\n
                # Take out this label and put it as a second line of this block
                ro = RE_eq_labels.search(s)
                if ro:
                    # construct new two-line math block, second line is :label:
                    s = ro.group(1) + ro.group(2) + '\n' +\
                        ro.group(1) + '   :label: ' + ro.group(3) + '\n\n'  
                
                # LyX table labes labels of the form :name: tab:<text> did not seem to work
                # So turn thise line a stand-alone targets below the first table block heading
                ro = RE_name_tab.search(s)
                if ro: # blank line followed by new targed .. _tab:<text:
                    s = '\n' +\
                        ro.group(1) + '.. _tab:' + ro.group(2) + ':\n'

                # LyX uses tab for table labels, sphinx uses tbl, so
                # replace `tab:` bij `tbl:` as required  by sphinx
                s = s.replace('tab:', 'tbl:')
                
                # The page references from LyX did not at all come pass thorugh to the .rst file.
                # To used remove them: Replace ` on page ` by ` `
                s = s.replace(' on page ', ' ')
                
                # Figure lines with label :alt: and figure captions all start with [label].
                # Remove them from the captions because looks ugly.
                ro = RE_label_in_captions.search(s)
                if ro:
                    s = ro.group(1) + ro.group(3)
                    
                # Replace inline references from LyX by sphinx-style one with their :role: attached, so that they work
                # The roles are different for fig and tbl (:numref:) for eq (:eq:) and sections (:ref:(
                while True:
                    ro = RE_refs_inline.findall(s)
                    if not ro:
                        # There are no more inline references
                        break
                    else:
                        # replace inline reference by its sphinx counterpart.
                        # ro is a list each  line a tuple with the groups for one label.
                        # Each time we only process the next label, so only use ro[0]
                        ro = ro[0]
                        
                        oldlabel = ro[0] # origina label [text] to be replaced in the total string
                        
                         # fig: and tbl: links require :numref: rol
                        if ro[2] in ['fig:', 'tbl:']:
                            newlabel = ':numref:`' + ro[2] + ro[3] + '`' 
                            
                        # eq: links require :eq: role
                        elif ro[2] in ['eq:']:
                            newlabel = ':eq:`' + ro[2] + ro[3] + '`'
                            
                        # other links require the normal :ref: role
                        elif ro[2] in ['sec:', 'subsec:', 'par:']:
                            newlabel = ':ref:`' + ro[2] + ro[3] + '`'
                            
                        # Should never happen if we tackled all possibilities.
                        # Make sure we didn't miss anything                        
                        else:
                            newlabel = ro[1] + ro[2] + ro[3] + '`'
                            raise ValueError("Unknown label in RE_refs_inline: {}".format(ro[2]))
                        
                        # Finally: replace the ole inline reference by the new one that sphinx understands
                        s = s.replace(oldlabel, newlabel)
                        
                # We may have equation labels embedded in multiline math blocks. If found, it should
                # become the second block line starting with :label:.
                # Since the label may in any line of the block, we need a stack (a list) to store the block,
                # and write it out afterwards with the label line placed second.
                # The stack is opened upon encountering the start of a muliline code block,
                # one that has .. math:: on a single line.
                ro = RE_embedded_math_labels.search(s)
                if ro:
                    # Embedded label found. Reconstruct s without label
                    s = ro.group(1) + ro.group(2) + ro.group(4) + '\n'
                    
                    # Construct and remember the :label:<mathlabe> and remember it for later.
                    indent = ' ' * stack[0].find('math::', 0) # should contain '.. math::'
                    mathlabel = indent + ':label: ' + ro.group(3) + '\n'
            
                # Make section underscore lines must fit the length of the section header.
                # This may no longer be the case since we removed the LyX label [text] from them.
                # So make sure they are the same length as the header (stored in the previous ine s_old)
                if len(s) > 9 and len(s_old) > 9 and len(s) != len(s_old) and np.all([s[0] == s_ for s_ in s[1:-1] ]):
                    s = s[0] * (len(s_old) - 1) + '\n'
                    
                # Prepend Chapter heading Bibliogfaphy before the bibliography
                if s == '.. container:: references csl-bib-body hanging-indent\n':
                    fout.write('Bibliography\n')
                    fout.write('============\n')
                    fout.write('\n')
                    
                # See if we have to add to the stack or empty the stack
                if len(stack): # The we know We are processing a multiline math block
                    # Check if we are over the end of the block.
                    # This is the case when we encountered a blank line for the second time.
                    if len(s) == 1 and len(stack) > 2: # The write the block to fout
                            fout.write(stack.pop(0))   # The block header `.. math::` line
                            if mathlabel:              # Not sure if this block has a mathlabel
                                fout.write(mathlabel)  # If we have it, write it as second line.
                            while len(stack) > 0:      # Write the rest of the block to fout
                                fout.write(stack.pop(0))
                            # The stack is now empty
                            mathlabel = '' # rest mathlabel
                            fout.write(s)  # write the blank line to fout.
                    # As long as we have not encountered the end of the math block
                    else:
                        # Don't write out, but store in the stack
                        stack.append(s)
                else: # We're not inside in math block
                    fout.write(s)
                s_old = s # Remember the last line (we may need it's length)
        logging.warning('... Outfile {} closed.'.format(outfile))
    logging.warning('... Infile {} closed.'.format(infile))
    logging.warning('Labels replaced, see {}'.format(outfile))
    return None

    
if __name__ == '__main__':
    
    basename = 'TransientGroundwater'
    
    # Project directory, where the LyX file resides.
    syllabus = '/Users/Theo/Instituten-Groepen-Overleggen/IHE/git_TransientGroundwaterFlow/SyllabusUptoDate/'
    home = '/Users/Theo/Instituten-Groepen-Overleggen/IHE/git_TransientGroundwaterFlow/readthedocs/Course2022/'
    bibfile = os.path.join(syllabus, basename  + '.bib')
    
    # Sphinx directories
    docs =   os.path.join(home,  'docs/')
    source = os.path.join(docs, 'source')
    build  = os.path.join(docs, 'build/') # not needed in this code
    
    for d in [syllabus, home, docs, source, build]:
        assert os.path.isdir(d), FileNotFoundError(d)
    
    os.chdir(source)
    logging.warning("Project dir: {}".format(os.getcwd()))
    
    # Input, intermediate and final files neede
    # The .tex file is obtained by exporting from LyX to `Latex(pdflatex)`
    texfile  = os.path.join(syllabus, basename + '.tex')
    rstfile0 = os.path.join(syllabus, basename + '.rst')
    tmpfile0 = os.path.join(source, basename + '.tmp' )
    rstfile1 = os.path.join(source, basename + '.rst')
    
    for fname in [texfile, bibfile]:
        assert os.path.isfile(fname), FileNotFoundError(fname)

    # start in the source directory
    logging.warning('Processing from {}'.format(source))
    os.chdir(source)
        
    # Setup pandoc command for converting .tex --> .rst
    if True:
        pandoc_cmd = ' '.join(
            [
            'pandoc -s',
            '--wrap=none',
            '--verbose',
            '--bibliography=' + bibfile,
            '--citeproc',
            '--default-image-extension=png',
            '-f latex',
            '-t rst',
            '-o '  + rstfile0,
            texfile,
        ])
        
        # And run it to generate the rstfile0
        logging.warning('running: ' + pandoc_cmd)
        os.system(pandoc_cmd) 

    if True:
        # Clean the multiple labels  ../../<basename>.rst --> ../../<basename>.tmp
        os.chdir(source)
        infile =  rstfile0
        outfile = tmpfile0

        counter = avoidDupNames(infile, outfile)

        print("Overview of duplicate labels found")
        print("==================================")
        print("Count,    multiple label")
        print("----------------------------------") 
        for k in counter:
            if counter[k] > 1:
                print('{1:4d} {0}'.format(k, counter[k]))
    
    if True:
        # Clean labels and references and some more ../../<basename>.tmp --> <basename>.rst
        infile =  tmpfile0
        outfile = rstfile1
            
        clean_labels_and_references(infile, outfile)                
                
    if False:
        # Make the html documenation in the build directory
        # There must be now errors in previous steps to run this one automatically.
        
        # Back to the docs directory
        os.chdir(docs)
        logging.warning(os.system('pwd'))
    
        # launch make clean followed by make html
        logging.warning('make clean')
        os.system('make clean')
    
        logging.warning('make html')
        os.system('make html')
        
        rm_cmd = 'rm ' + rstfile0 + ' ' + outfile0
        logging.warning(rm_cmd)
        os.system(rm_cmd)

        print('Done, see html documentation in {}/html'.format(build))
    else:
        print("Without errors inthe previous steps, you should:")
        print("cd {}".format(docs))
        print("make clean; make html")
        
    os.system(' '.join(['rm', tmpfile0]))
